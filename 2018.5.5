 
【需求分析 】：C语言中关于字符串的函数有很多，但往往需要的是靠自己去理解，去实现。
 
1. 实现函数my_strlen()
 
【功能描述】 ：返回字符串的长度
  
*******************************************************************************************************************
方法一 ：
int my_strlen(const char *str)
{
    int count = 0;
    assert(str);
    while(*str)
    {
      count++;
      str++；
    }
    return count;
}
方法二 ：
int my_strlen(const char *str)
{
    assert(str);
    if(*str == '\0');
   {
       return 0;
   }
    else
   {
       return 1+my_strlen(str+1);
   }
}
方法三 ：
int my_strlen(const char *str)
{ 
    char *p = str;
    assert(str);
    while(*p)
    {
      p++;
    }
    return p-str;
}
*******************************************************************************************************************


2. 实现函数my_strcpy()
 
【功能描述】 ：第一个字符串被第二个字符串所覆盖
  
*******************************************************************************************************************
char *my_strcpy(char *dest, const char *str)
{
    char *temp = dest;
    assert(str);
    assert(dest);
    while(*temp++ = *str++)
    { 
             ;
    }
    return dest;
}
*******************************************************************************************************************

3. 实现函数my_strncpy()
 
【功能描述】 ：有个数限制字符串复制
  
*******************************************************************************************************************
char *my_strncpy(char *dest, const char *str,size_t count)
{
    int i = 0;
    char *temp = dest;
    assert(str);
    assert(dest);
    while(count--)
    {  
       if(*str == '\0');
       {
           return NULL;  
       }
       *temp++ = *str++;
    }
    if(*temp != '\0')
    {
         *temp = '\0';
    }
    return dest;
}
*******************************************************************************************************************

4. 实现函数my_strcat()
 
【功能描述】 ：将第二个字符串链接在第一个字符串后面
  
*******************************************************************************************************************
char *my_strcat(char *dest, const char *str)
{
    char *temp = dest;
    assert(str);
    assert(dest);
    while(*temp)
    {
        temp++;
    }
    while(*temp++ = *str++)
    {
            ;
    }
    return dest;
  
    }
    return dest;
}
*******************************************************************************************************************

5. 实现函数my_strcmp()
 
【功能描述】 ：比较两个字符串大小（比较acsll码值），大于返回大于零的数，小于零返回小于零的数，否则返回零。
  
*******************************************************************************************************************
int  my_strcmp（const char *str1, const char *str2）
{
    assert(str1);
    assert(str2);
    while(*str1 == *str2)
    {
         if(*str1 == '\0')
         {
            return 0;
         }
         str1++;
         str2++;
    }
    return srt1 - str2;
 
}
*******************************************************************************************************************
6. 实现函数my_strstr()
 
【功能描述】 ：看第一个串是否包含第二个串，不包含返回NULL，否则返回 串所在第一个位置
  
*******************************************************************************************************************
char *my_strstr(const char *str1,const char *str2)
{
    assert(str1);
    assert(str2);
    
    char *s1 = (char *)srt1;
    char *s2 = (char *)str2;
    char *cur = NULL;
    
    if(*str2 == '\0')
        return (char *)str1;
    while(*s1)
    {
        cur = s1;
        s2 = str2;
        while(*s1 && *s2 && (*s1 == *s2))
        {
            s1++;
            s2++;
        }
        if(*s2 == '\0')
            return s1;
        s1++;
    }
}
*******************************************************************************************************************
7. 实现函数my_memcpy()
 
【功能描述】 ：将第二个参数按字节复制到第一个字符串（两参数分别在两块独立内存）
  
********************************************************************************************************************
void *my-memcpy(void *dest ,const void *str,size_t count)
{
    void * temp = dest;
    
    assert(dest);
    assert(str);
    
    //从前到后按字节复制
    while(count--)
    {
        *(char *)temp = *(char *)str;
        temp = (char *)temp + 1;
        str = (char *)str + 1;
    }
    return dest;
} 
*******************************************************************************************************************
7. 实现函数my_memmove()
 
【功能描述】 ：将第二个参数按字节复制到第一个字符串（内存块可重叠）(字符  数组  整数......都可以复制)
  
*******************************************************************************************************************
void * memmove(void *dest, const void *str,size_t count)
{
    void * temp = dest;
    assert(dest);
    assert(str);
    
    if(temp <= str)
    {
       while(count--)
       {
        *(char *)temp = *(char *)str;
        temp = (char *)temp + 1;
        str = (char *)str + 1;
       } 
    }
    else
    {
        temp = (char *)temp + count - 1;
        str = (char *)str + count - 1;
        
        while(count--)
        {
            *(char *)temp = *(char *)str;
            temp = (char *)temp - 1;
            str = (cahr *)str - 1;
        }
    }
    return dest;
}
*******************************************************************************************************************
8. 实现函数my_strcat()
 
【功能描述】 ：将第二个字符串链接在第一个字符串后面
  
*******************************************************************************************************************
*******************************************************************************************************************
9. 实现函数my_strcat()
 
【功能描述】 ：将第二个字符串链接在第一个字符串后面
  
*******************************************************************************************************************
*******************************************************************************************************************
10. 实现函数my_strcat()
 
【功能描述】 ：将第二个字符串链接在第一个字符串后面
  
*******************************************************************************************************************
*******************************************************************************************************************
4. 实现函数my_strcat()
 
【功能描述】 ：将第二个字符串链接在第一个字符串后面
  
*******************************************************************************************************************
*******************************************************************************************************************
